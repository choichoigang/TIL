# lexical scoping

프로그래밍에서 스코프는 변수가 유효한 범위를 나타내며 , 스코프는 정적 스코프와 동적 스코프로 분리할 수 있습니다.

1. 정적 스코프 : 함수를 선언하는 시점에서 스코프의 단위가 결정된다.
2. 동적 스코프 : 함수를 호출하는 시점에서 스코프의 단위가 결정된다.

JS의 스코프 단위는 Lexical Scope라고 불리며 이는 동적 스코프라고 이해할 수 있습니다.

예제

```jsx
// Lexical scoping(정적 스코프)

// Lexical scoping의 특징은 함수를 선언하는 시점에서 스코프의 담위가 결정 됩니다.
const a = 22;

// 아래의 foo 함수가 선언될 때 a의 값은 전역에 22를 바라보게 됩니다.
const foo = () => console.log(a);

// 이 후 foo2 함수 내부에서 블록 단위의 변수 a를 선언한다고 해도 foo의 스코프 단위는 전역 상태의 a가 동적으로 결정됬다고 할 수 있습니다.
const foo2 = () => {
  const a = 33;
  foo();
};

// foo2 함수를 호출 한다면 결과는 22가 나오게 됩니다.
foo2();

// Dynamic Scope(동적 스코프)

// 만약에 JS가 유효한 스코프의 범위를 동적으로 결정 된다고 가정하면 어떻게 될까요 ?
const a = 22;

const foo = () => console.log(a);

const foo2 = () => {
  const a = 33;
  // foo는 foo2 내부의 변수인 a를 바라보게 됩니다.
  foo();
};

foo2();
// 33
```

## 문제점

한번 전역의 변수를 바라보게 된 함수는 바라보는 스코프의 범위를 바꿀 방법이 없습니다.

이런 상황에서 프로젝트의 규모가 커지고 전역에 환경을 많이 사용했다면 에러를 수정하는데 큰 어려움을 겪을 수 있습니다.

위 코드와 같이 혼란을 주는 상황을 방지하기 위해서는 여러 해결 방안이 있겠지만 가장 크게 생각나는 2가지 해결 방안에 대해서 말해 보도록 하겠습니다.

- 함수를 생성할 때 전역 상태에 의존하지 않도록 작성한다.

```jsx
// 아까와 달리 foo2 함수는 인자를 받아서 내부 스코프에서 a의 값을 정해주고 있습니다.
// foo 함수 역시 arg로 전달받은 결과를 logging하고 있습니다.
const a = 22;

const foo = (arg) => console.log(arg);

const foo2 = (arg) => {
  // arg를 foo2 스코프의 a의 값에 할당합니다.
  const a = arg;
  // foo 함수에 foo2 스코프 단위의 a의 값을 인자로 전달합니다.
  foo(a);
};

// 전역 상태의 a를 전달합니다.
foo2(a);
// 22
```

- 함수 안의 지역 변수 또는 객체 안의 속성

```jsx
// 만약에 지역과 전역에 같은 변수명이 있다고 한다면 스코프는 가장 가까이 있는 스코프의 단위부터 탐색하게 됩니다.
const a = 33;

const foo = () => {
  const a = 22;
  console.log(a);
};

foo();

// 객체 안의 속성으로 이용할 경우에는 js의 this에 대해서 이해가 필요하다.
// js의 this는 동적으로 결정되기 때문입니다.

const a = 33;

const obj = {
  a: 22,
  func() {
    console.log(this.a);
  },
};

obj.func();
// 22
```
